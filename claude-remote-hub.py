#!/usr/bin/env python3
"""
Claude Remote Hub — Access your Claude Code sessions from any device via Tailscale.
A lightweight web server that manages ttyd + tmux terminal sessions.
"""

from typing import Optional
import subprocess
import os
import sys
import signal
import time
import json
import hashlib
import shutil
import socket
import platform as _platform
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
from urllib.parse import unquote, parse_qs, urlparse
from datetime import datetime

VERSION = "3.0.1"

# ─── Platform Detection ─────────────────────────────────────────────────────

PLATFORM = _platform.system().lower()  # 'darwin', 'linux', 'windows'

IS_WSL = False
if PLATFORM == "linux":
    try:
        with open("/proc/version", "r") as f:
            IS_WSL = "microsoft" in f.read().lower()
    except FileNotFoundError:
        pass


def _find_bin(name: str) -> str:
    """Locate a binary on PATH. Returns the name itself as fallback."""
    path = shutil.which(name)
    return path if path else name


# ─── Config ──────────────────────────────────────────────────────────────────

HUB_PORT = int(os.environ.get("CLAUDE_REMOTE_HUB_PORT", 7680))
BASE_PORT = 7700
MAX_PORT = 7799
TTYD_BIN = os.environ.get("TTYD_BIN", _find_bin("ttyd"))
TMUX_BIN = os.environ.get("TMUX_BIN", _find_bin("tmux"))
CLAUDE_BIN = os.environ.get("CLAUDE_BIN", _find_bin("claude"))
FONT_SIZE = int(os.environ.get("CLAUDE_FONT_SIZE", 11))
DEV_ROOT = os.environ.get("CLAUDE_DEV_ROOT", os.path.expanduser("~/Projects"))
INSTALL_DIR = os.environ.get("CLAUDE_REMOTE_HUB_DIR", os.path.expanduser("~/.claude-remote-hub"))

IGNORED_DIRS = {".git", "node_modules", "__pycache__", "venv", ".venv", ".tox",
                ".mypy_cache", ".pytest_cache", "dist", "build", ".next", ".nuxt"}

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
_template_cache: dict[str, str] = {}

# ─── Helpers ─────────────────────────────────────────────────────────────────


def _check_dependencies() -> list[str]:
    """Check that required external tools are installed and return missing ones."""
    missing = []
    for name in ("tmux", "ttyd"):
        if not shutil.which(name):
            missing.append(name)
    return missing


def _dependency_install_hint(name: str) -> str:
    """Return platform-specific install instructions for a missing dependency."""
    hints = {
        "tmux": {
            "darwin": "brew install tmux",
            "linux": "sudo apt install tmux  # or: sudo dnf install tmux / sudo pacman -S tmux",
        },
        "ttyd": {
            "darwin": "brew install ttyd",
            "linux": "sudo snap install ttyd --classic  # or build from source: https://github.com/tsl0922/ttyd",
        },
    }
    platform_key = "darwin" if PLATFORM == "darwin" else "linux"
    return hints.get(name, {}).get(platform_key, f"Install {name} and ensure it is on your PATH")


def _load_template(name: str) -> str:
    """Load an HTML template from templates/ with in-memory caching."""
    if name not in _template_cache:
        path = os.path.join(SCRIPT_DIR, "templates", name)
        with open(path, "r", encoding="utf-8") as f:
            _template_cache[name] = f.read()
    return _template_cache[name]


def port_for_name(name: str) -> int:
    """Generate a deterministic port (7700-7799) from a session name."""
    h = int(hashlib.md5(name.encode()).hexdigest(), 16)
    return BASE_PORT + (h % (MAX_PORT - BASE_PORT))


def _port_in_use_socket(port: int) -> bool:
    """Check if a port is in use via socket connection attempt."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(0.5)
        return s.connect_ex(("127.0.0.1", port)) == 0


def _get_listening_ports_lsof() -> set[int]:
    """Get listening ports in 7700-7799 range using lsof (macOS/Linux)."""
    lsof = shutil.which("lsof")
    if not lsof:
        return set()
    try:
        out = subprocess.check_output(
            [lsof, "-iTCP:7700-7799", "-sTCP:LISTEN", "-P", "-n"],
            text=True, stderr=subprocess.DEVNULL
        )
        ports: set[int] = set()
        for line in out.strip().split("\n"):
            if "LISTEN" in line:
                for part in line.split():
                    if ":" in part and part.split(":")[-1].isdigit():
                        ports.add(int(part.split(":")[-1]))
        return ports
    except (subprocess.CalledProcessError, FileNotFoundError):
        return set()


def _get_listening_ports_ss() -> set[int]:
    """Get listening ports in 7700-7799 range using ss (Linux)."""
    ss = shutil.which("ss")
    if not ss:
        return set()
    try:
        out = subprocess.check_output(
            [ss, "-tlnH"], text=True, stderr=subprocess.DEVNULL
        )
        ports: set[int] = set()
        for line in out.strip().split("\n"):
            parts = line.split()
            for part in parts:
                if ":" in part:
                    port_str = part.rsplit(":", 1)[-1]
                    if port_str.isdigit():
                        port = int(port_str)
                        if BASE_PORT <= port <= MAX_PORT:
                            ports.add(port)
        return ports
    except (subprocess.CalledProcessError, FileNotFoundError):
        return set()


def get_ttyd_ports() -> set[int]:
    """Return the set of ports where ttyd is currently listening."""
    ports = _get_listening_ports_lsof()
    if not ports and PLATFORM == "linux":
        ports = _get_listening_ports_ss()
    return ports


def port_in_use(port: int) -> bool:
    """Check if a TCP port is currently in use."""
    lsof = shutil.which("lsof")
    if lsof:
        r = subprocess.run([lsof, "-i", f":{port}"], capture_output=True)
        return r.returncode == 0

    ss = shutil.which("ss")
    if ss:
        r = subprocess.run(
            [ss, "-tlnH", f"sport = :{port}"],
            capture_output=True, text=True
        )
        return bool(r.stdout.strip())

    return _port_in_use_socket(port)


def get_sessions() -> list[dict]:
    """List active Claude tmux sessions with their status."""
    try:
        from concurrent.futures import ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=2) as ex:
            tmux_future = ex.submit(
                subprocess.check_output,
                [TMUX_BIN, "list-sessions", "-F",
                 "#{session_name}|#{session_activity}|#{session_windows}|#{session_attached}"],
                text=True, stderr=subprocess.DEVNULL
            )
            ports_future = ex.submit(get_ttyd_ports)
            out = tmux_future.result(timeout=3)
            ttyd_ports = ports_future.result(timeout=3)
        sessions: list[dict] = []
        for line in out.strip().split("\n"):
            if not line.startswith("claude-"):
                continue
            parts = line.split("|")
            name = parts[0].removeprefix("claude-")
            try:
                last_activity = datetime.fromtimestamp(int(parts[1]))
                time_str = last_activity.strftime("%H:%M")
            except (ValueError, IndexError):
                time_str = "?"
            attached = parts[3] if len(parts) > 3 else "0"
            port = port_for_name(name)
            sessions.append({
                "name": name,
                "port": port,
                "time": time_str,
                "attached": attached != "0",
                "has_ttyd": port in ttyd_ports,
            })
        return sessions
    except (subprocess.CalledProcessError, FileNotFoundError):
        return []


def get_folders(rel_path: str = "") -> dict:
    """List subdirectories under DEV_ROOT for the folder picker."""
    base = os.path.realpath(DEV_ROOT)
    if not os.path.isdir(base):
        base = os.path.expanduser("~")

    target = os.path.realpath(os.path.join(base, rel_path)) if rel_path else base

    if not target.startswith(base):
        target = base
    if not os.path.isdir(target):
        target = base

    folders: list[str] = []

    try:
        for entry in sorted(os.scandir(target), key=lambda e: e.name.lower()):
            if entry.is_dir() and not entry.name.startswith(".") and entry.name not in IGNORED_DIRS:
                folders.append(entry.name)
    except (PermissionError, FileNotFoundError, OSError):
        pass

    display_path = os.path.relpath(target, base)
    if display_path == ".":
        display_path = ""

    return {
        "folders": folders,
        "current": display_path,
        "absolute": target,
        "can_go_up": target != base,
        "root_name": os.path.basename(base),
    }


def start_session(name: str, directory: Optional[str] = None, skip_permissions: bool = False) -> int:
    """Start a tmux + ttyd session. Returns the assigned port."""
    port = port_for_name(name)
    session = f"claude-{name}"

    r = subprocess.run([TMUX_BIN, "has-session", "-t", session],
                       capture_output=True)
    if r.returncode != 0:
        cmd = [TMUX_BIN, "new-session", "-d", "-s", session]
        if directory and os.path.isdir(directory):
            cmd += ["-c", directory]
        cmd.append(CLAUDE_BIN)
        if skip_permissions:
            cmd.append("--dangerously-skip-permissions")
        subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        time.sleep(0.5)
        subprocess.run([TMUX_BIN, "set-option", "-t", session, "mouse", "on"],
                       capture_output=True)

    if not port_in_use(port):
        ttyd_cmd = [
            TTYD_BIN, "-W", "-p", str(port),
            "--ping-interval", "5",
            "-t", f"fontSize={FONT_SIZE}",
            "-t", 'theme={"background":"#0f0f1a","foreground":"#e8e8f0","cursor":"#7c83ff"}',
            "-t", "titleFixed=Claude Remote Hub",
        ]
        # Custom index file for virtual keyboard overlay
        custom_index = os.path.join(INSTALL_DIR, "ttyd-index.html")
        if os.path.exists(custom_index):
            ttyd_cmd += ["-I", custom_index]

        # HTTPS: use certs if available
        cert_file = os.path.join(INSTALL_DIR, "hub.crt")
        key_file = os.path.join(INSTALL_DIR, "hub.key")
        if os.path.exists(cert_file) and os.path.exists(key_file):
            ttyd_cmd += ["-S", "-C", cert_file, "-K", key_file]

        ttyd_cmd += ["tmux", "attach-session", "-t", session]
        subprocess.Popen(
            ttyd_cmd,
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        time.sleep(0.3)

    return port


def stop_session(name: str) -> None:
    """Stop ttyd and kill the tmux session."""
    port = port_for_name(name)
    session = f"claude-{name}"

    pkill = shutil.which("pkill")
    if pkill:
        subprocess.run([pkill, "-f", f"ttyd.*-p {port}"],
                       capture_output=True)
    else:
        # Fallback: find and kill ttyd process via port
        try:
            lsof = shutil.which("lsof")
            if lsof:
                out = subprocess.check_output(
                    [lsof, "-ti", f":{port}"], text=True, stderr=subprocess.DEVNULL
                ).strip()
                for pid_str in out.split("\n"):
                    if pid_str.isdigit():
                        os.kill(int(pid_str), signal.SIGTERM)
        except (subprocess.CalledProcessError, ValueError):
            pass

    subprocess.run([TMUX_BIN, "kill-session", "-t", session],
                   capture_output=True)


# ─── HTML Rendering ─────────────────────────────────────────────────────────

def render_hub(host: str) -> str:
    """Render the dashboard with active sessions."""
    sessions = get_sessions()

    session_cards = ""
    for s in sessions:
        status_class = "active" if s["has_ttyd"] else "idle"
        attached_badge = '<span class="badge active">connected</span>' if s["attached"] else ""
        session_cards += f"""
        <div class="card">
          <a href="/start/{s['name']}" class="card-link">
            <div class="card-left">
              <span class="status-dot {status_class}"></span>
              <div>
                <div class="card-name">{s['name']}</div>
                <div class="card-meta">port {s['port']} &middot; {s['time']}</div>
              </div>
            </div>
            <div class="card-right">
              {attached_badge}
              <span class="arrow">&rsaquo;</span>
            </div>
          </a>
          <button class="stop-btn" onclick="event.preventDefault();if(confirm('Stop session {s['name']}?'))location='/stop/{s['name']}'">
            <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 1l12 12M13 1L1 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
          </button>
        </div>"""

    if not sessions:
        session_cards = """
        <div class="empty">
          <svg class="empty-icon" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>
          </svg>
          <p>No active sessions</p>
          <p class="empty-sub">Create one below to get started</p>
        </div>"""

    count = len(sessions)
    count_text = f"{count} active session" if count == 1 else f"{count} active sessions"

    html = _load_template("hub.html")
    return (html
            .replace("{{COUNT_TEXT}}", count_text)
            .replace("{{SESSION_CARDS}}", session_cards)
            .replace("{{VERSION}}", VERSION))


def render_terminal(name: str, port: int, host: str) -> str:
    """Render the terminal wrapper page."""
    terminal_url = f"https://{host}:{port}"
    html = _load_template("terminal.html")
    return html.replace("{{SESSION_NAME}}", name).replace("{{TERMINAL_URL}}", terminal_url)


# ─── HTTP Handler ────────────────────────────────────────────────────────────

class HubHandler(BaseHTTPRequestHandler):
    def _cors_headers(self):
        origin = self.headers.get("Origin", "")
        if origin:
            self.send_header("Access-Control-Allow-Origin", origin)
            self.send_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
            self.send_header("Access-Control-Allow-Headers", "Content-Type")

    def do_OPTIONS(self):
        self.send_response(204)
        self._cors_headers()
        self.end_headers()

    def do_GET(self):
        parsed = urlparse(self.path)
        path = unquote(parsed.path)
        qs = parse_qs(parsed.query)

        # Start session
        if path.startswith("/start/"):
            name = path.split("/start/")[1].strip("/")
            if not name:
                self.send_response(302)
                self.send_header("Location", "/")
                self.end_headers()
                return
            directory = qs.get("dir", [None])[0]
            skip_permissions = qs.get("skip_permissions", ["0"])[0] == "1"
            start_session(name, directory, skip_permissions)
            self.send_response(302)
            self.send_header("Location", f"/terminal/{name}")
            self.end_headers()
            return

        # Terminal wrapper
        if path.startswith("/terminal/"):
            name = path.split("/terminal/")[1].strip("/")
            if not name:
                self.send_response(302)
                self.send_header("Location", "/")
                self.end_headers()
                return
            port = port_for_name(name)
            host = self.headers.get("Host", "localhost").split(":")[0]
            html = render_terminal(name, port, host)
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.send_header("Cache-Control", "no-cache")
            self.end_headers()
            self.wfile.write(html.encode())
            return

        # Stop session
        if path.startswith("/stop/"):
            name = path.split("/stop/")[1].strip("/")
            stop_session(name)
            self.send_response(302)
            self.send_header("Location", "/")
            self.end_headers()
            return

        # API: list sessions (JSON)
        if path == "/api/sessions":
            sessions = get_sessions()
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(json.dumps(sessions).encode())
            return

        # API: check if ttyd is ready
        if path.startswith("/api/ttyd-ready/"):
            name = path.split("/api/ttyd-ready/")[1].strip("/")
            port = port_for_name(name)
            ready = port_in_use(port)
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.send_header("Cache-Control", "no-cache, no-store")
            self.end_headers()
            self.wfile.write(json.dumps({"ready": ready, "port": port}).encode())
            return

        # Download SSL certificate
        if path == "/cert":
            cert_path = os.path.join(INSTALL_DIR, "hub.crt")
            if os.path.exists(cert_path):
                with open(cert_path, "rb") as f:
                    cert_data = f.read()
                self.send_response(200)
                self.send_header("Content-Type", "application/x-x509-ca-cert")
                self.send_header("Content-Disposition", "attachment; filename=claude-remote-hub.crt")
                self.end_headers()
                self.wfile.write(cert_data)
            else:
                self.send_response(404)
                self.end_headers()
            return

        # API: list folders
        if path == "/api/folders":
            rel_path = qs.get("path", [""])[0]
            data = get_folders(rel_path)
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(json.dumps(data).encode())
            return

        # Icon
        if path == "/icon.png":
            icon_path = os.path.join(INSTALL_DIR, "icon_chub.png")
            if not os.path.exists(icon_path):
                icon_path = os.path.join(SCRIPT_DIR, "icon_chub.png")
            if os.path.exists(icon_path):
                with open(icon_path, "rb") as f:
                    icon_data = f.read()
                self.send_response(200)
                self.send_header("Content-Type", "image/png")
                self.send_header("Cache-Control", "public, max-age=86400")
                self.end_headers()
                self.wfile.write(icon_data)
            else:
                self.send_response(404)
                self.end_headers()
            return

        # Hub dashboard
        host = self.headers.get("Host", f"localhost:{HUB_PORT}")
        html = render_hub(host)
        self.send_response(200)
        self.send_header("Content-Type", "text/html; charset=utf-8")
        self.send_header("Cache-Control", "no-cache")
        self.end_headers()
        self.wfile.write(html.encode())

    def _send_json(self, data: dict, status: int = 200):
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self._cors_headers()
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def do_POST(self):
        parsed = urlparse(self.path)
        path = unquote(parsed.path)

        # API: send special key via tmux
        if path.startswith("/api/send-keys/"):
            name = path.split("/api/send-keys/")[1].strip("/")
            session = f"claude-{name}"
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            data = json.loads(body)
            key = data.get("key", "")

            allowed_keys = {
                "Escape", "Tab", "BTab", "Enter", "Space",
                "Up", "Down", "Left", "Right",
                "C-c", "C-v", "C-z", "C-d", "C-l", "C-a", "C-e",
                "C-r", "C-w", "C-u", "C-k", "C-b", "C-f", "C-n", "C-p",
            }

            if key not in allowed_keys:
                self._send_json({"error": "key not allowed"}, 400)
                return

            subprocess.run(
                [TMUX_BIN, "send-keys", "-t", session, key],
                capture_output=True
            )
            self._send_json({"ok": True})
            return

        # API: send text (paste) via tmux
        if path.startswith("/api/send-text/"):
            name = path.split("/api/send-text/")[1].strip("/")
            session = f"claude-{name}"
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            data = json.loads(body)
            text = data.get("text", "")

            if not text or len(text) > 10000:
                self._send_json({"error": "invalid text"}, 400)
                return

            proc = subprocess.run(
                [TMUX_BIN, "load-buffer", "-"],
                input=text, capture_output=True, text=True
            )
            if proc.returncode == 0:
                subprocess.run(
                    [TMUX_BIN, "paste-buffer", "-t", session],
                    capture_output=True
                )

            self._send_json({"ok": True})
            return

        # API: scroll via tmux copy-mode
        if path.startswith("/api/scroll/"):
            name = path.split("/api/scroll/")[1].strip("/")
            session = f"claude-{name}"
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            data = json.loads(body)
            direction = data.get("direction", "")

            if direction not in ("up", "down"):
                self._send_json({"error": "invalid direction"}, 400)
                return

            subprocess.run(
                [TMUX_BIN, "copy-mode", "-t", session],
                capture_output=True
            )
            key = "PageUp" if direction == "up" else "PageDown"
            subprocess.run(
                [TMUX_BIN, "send-keys", "-t", session, key],
                capture_output=True
            )

            self._send_json({"ok": True})
            return

        self.send_response(404)
        self.end_headers()

    def log_message(self, format, *args):
        pass


# ─── CLI ─────────────────────────────────────────────────────────────────────

def find_hub_pid() -> Optional[int]:
    """Find the PID of a running Claude Remote Hub server on HUB_PORT."""
    lsof = shutil.which("lsof")
    if lsof:
        try:
            out = subprocess.check_output(
                [lsof, "-ti", f":{HUB_PORT}"], text=True, stderr=subprocess.DEVNULL
            ).strip()
            if out:
                return int(out.split("\n")[0])
        except (subprocess.CalledProcessError, ValueError):
            pass

    ss = shutil.which("ss")
    if ss:
        try:
            out = subprocess.check_output(
                [ss, "-tlnpH", f"sport = :{HUB_PORT}"],
                text=True, stderr=subprocess.DEVNULL
            ).strip()
            for line in out.split("\n"):
                if "pid=" in line:
                    for part in line.split(","):
                        if part.startswith("pid="):
                            return int(part.split("=")[1])
        except (subprocess.CalledProcessError, ValueError):
            pass

    return None


def cmd_stop():
    pid = find_hub_pid()
    if pid:
        os.kill(pid, signal.SIGTERM)
        print(f"  Claude Remote Hub stopped (PID {pid})")
    else:
        print("  Claude Remote Hub is not running")
    pkill = shutil.which("pkill")
    if pkill:
        subprocess.run([pkill, "-f", "ttyd.*-p 77"], capture_output=True)


def cmd_status():
    pid = find_hub_pid()
    if pid:
        print(f"  Claude Remote Hub running (PID {pid}, port {HUB_PORT})")
        sessions = get_sessions()
        if sessions:
            for s in sessions:
                dot = "*" if s["has_ttyd"] else "o"
                print(f"   [{dot}] {s['name']} (port {s['port']}, {s['time']})")
        else:
            print("   No active sessions")
    else:
        print("  Claude Remote Hub is stopped")


def cmd_start():
    # Check dependencies before starting
    missing = _check_dependencies()
    if missing:
        print("  Missing required dependencies:")
        for name in missing:
            hint = _dependency_install_hint(name)
            print(f"    - {name}: {hint}")
        sys.exit(1)

    def cleanup(sig, frame):
        print("\n  Stopping Claude Remote Hub...")
        sessions = get_sessions()
        pkill = shutil.which("pkill")
        for s in sessions:
            port = s["port"]
            if pkill:
                subprocess.run([pkill, "-f", f"ttyd.*-p {port}"], capture_output=True)
        sys.exit(0)

    signal.signal(signal.SIGINT, cleanup)
    signal.signal(signal.SIGTERM, cleanup)

    proto = "http"
    cert_file = os.path.join(INSTALL_DIR, "hub.crt")
    key_file = os.path.join(INSTALL_DIR, "hub.key")
    has_ssl = os.path.exists(cert_file) and os.path.exists(key_file)
    if has_ssl:
        proto = "https"

    platform_label = PLATFORM
    if IS_WSL:
        platform_label = "wsl"

    print(f"""
  Claude Remote Hub v{VERSION} ({platform_label})

  {proto}://localhost:{HUB_PORT}
  Sessions use ports {BASE_PORT}-{MAX_PORT}
  {"HTTPS enabled" if has_ssl else "HTTPS not configured (optional)"}
  Press Ctrl+C to stop
""")

    class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
        daemon_threads = True

    server = ThreadedHTTPServer(("0.0.0.0", HUB_PORT), HubHandler)

    if has_ssl:
        import ssl
        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ctx.load_cert_chain(cert_file, key_file)
        ctx.minimum_version = ssl.TLSVersion.TLSv1_2
        ctx.set_ciphers("ECDHE+AESGCM:ECDHE+CHACHA20:!aNULL:!MD5")
        ctx.options |= ssl.OP_NO_COMPRESSION | ssl.OP_CIPHER_SERVER_PREFERENCE
        server.socket = ctx.wrap_socket(server.socket, server_side=True)

    server.serve_forever()


def main():
    cmd = sys.argv[1] if len(sys.argv) > 1 else "start"

    if cmd == "stop":
        cmd_stop()
    elif cmd == "restart":
        cmd_stop()
        time.sleep(1)
        cmd_start()
    elif cmd == "status":
        cmd_status()
    elif cmd == "start":
        cmd_start()
    elif cmd == "logs":
        os.execvp("tail", ["tail", "-f",
                           os.path.join(INSTALL_DIR, "hub.log"),
                           os.path.join(INSTALL_DIR, "hub-error.log")])
    else:
        print(f"Usage: claude-remote-hub.py {{start|stop|restart|status|logs}}")
        sys.exit(1)


if __name__ == "__main__":
    main()
